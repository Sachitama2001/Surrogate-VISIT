# Surrogate-VISIT

This repository collects two complementary workflows around the VISIT (Vegetation Integrative Simulator for Trace gases) long-term forest site (LHP):

1. **Parameter sensitivity screening** driven by Morris/elementary effects.
2. **A deep-learning surrogate (LSTM) for flux emulation and inverse modeling.**

The goal is to evaluate overstory/understory behavior quickly and to automate parameter recalibration against observed fluxes.

## Repository Layout

| Directory | Purpose | Notes |
| --- | --- | --- |
| `LHP_elementary_effects/` | Morris-based screening workspace: SALib design generation, VISIT runners, μ*/σ aggregation, plotting utilities. | See `LHP_elementary_effects/README.md`. |
| `ML_LHP_LSTM/` | LSTM surrogate with static-parameter conditioning for GPP/NPP/NEP/Rh multi-step forecasts plus observation-driven inversion. | See `ML_LHP_LSTM/README.md`. |
| `LHP_elementary_effects/docs/*`, `ML_LHP_LSTM/docs/*` | Metadata, experiment plans, and reproducibility notes. | Updated frequently as research notes. |

## Quick Start

1. **Clone and inspect the workspace**
	 ```bash
	 git clone https://github.com/Sachitama2001/Surrogate-VISIT.git
	 cd Surrogate-VISIT
	 ls -1
	 ```
2. **Python environments**
	 - All analysis/training scripts assume Python ≥3.10.
	 - Install the surrogate dependencies inside a virtual environment:
		 ```bash
		 cd ML_LHP_LSTM
		 pip install -r requirements.txt
		 ```
3. **VISIT binaries**
	 - The Morris pipeline calls the VISIT v1.1 sources living under `/mnt/d/VISIT/honban/point/ex/CODE_LHP/`.
	 - `scripts/run_morris_experiments.py` recompiles `visitb` if needed, so make sure netCDF/gfortran and other build dependencies are available in your PATH.

## Recommended Workflow

### 1. Morris-Based Screening
- Review variable indices, baseline values, and recommended step widths in `LHP_elementary_effects/docs/parameter_metadata.csv`.
- Configure trajectory count, grid levels, and deltas via `configs/elementary_effects_config.json`.
- Reproduce the full pipeline (design → VISIT runs → metric extraction → effect sizes) with:
	```bash
	cd LHP_elementary_effects
	conda run -n deepl python scripts/prepare_morris_design.py --config configs/elementary_effects_config.json
	conda run -n deepl python scripts/run_morris_experiments.py --config configs/elementary_effects_config.json
	conda run -n deepl python scripts/analyze_morris_effects.py
	```
- Plots showing the top μ* parameters are written to `results/morris_effects/plots/*` and can feed subsequent LHS/Sobol or surrogate experiments.

### 2. LSTM Surrogate & Inversion
- Copy the normalized perturbation outputs (`OUTPUT_PERTURBATION_LHP_V2_LHS`) and static parameters (`parameter_summary.csv`) into `ML_LHP_LSTM/data/`.
- Train via `python train.py` (tune the `config` dict inside the script as needed).
- Evaluate or invert:
	- `evaluate_parameter_recovery.py` validates recovery against known VISIT runs.
	- `test_inversion.py --mode observation` performs parameter inversion from observed NEP (e.g., JapanFlux windows).
- Typical artifacts (`inverse_results/*`, `visualizations/*`) include NEP comparisons, parameter bars, and scatter plots. Model checkpoints live in `artifacts/` alongside `config.json` and `training_history.json` for provenance.

## Data & Artifacts
- Raw VISIT inputs/outputs and proprietary datasets (e.g., JapanFlux CSVs) are not stored in this repository; mount them from `/mnt/d/VISIT/honban/...` or your own data path.
- Large autogenerated directories (`results/`, `artifacts/`, `logs/`, …) are ignored by Git. When publishing, share aggregated tables or figures instead of the full binary outputs.

## Contributing
- Issues and pull requests are welcome, but expect breaking changes on research branches. The `main` branch should always stay buildable and reproducible.
- When adding analyses or visualizations, update the corresponding submodule README and capture the steps under `docs/` for reproducibility.

## License

Usage is currently restricted to research purposes (no formal OSS license yet). Contact the maintainer before redistributing code or results outside the project context.
